# Universal Implementation Plan Generator - v1.0.0 (Original)

**Initial Release: 2025-11-05**
**Status**: Superseded by v2.0.0
**Mode**: Code Implementation Only

---

## OBJECTIVE

Generate a zero-assumption, bulletproof implementation plan for Claude Code execution through exhaustive investigation and documentation. This protocol **produces plans only** - it does NOT implement changes.

---

## PROTOCOL EXECUTION

### PHASE 1: TASK CLASSIFICATION

<task_assessment>
Analyze the provided task and document:

**Task Type** (select one):
- [ ] New Feature Implementation
- [ ] Bug Fix / Debugging
- [ ] Refactoring / Optimization
- [ ] Integration / API Work
- [ ] Infrastructure / Tooling

**Complexity Classification** (auto-determine):
- **Low**: 1-3 files, isolated change, <100 LOC affected
- **Medium**: 4-10 files, some integration, 100-500 LOC affected
- **High**: 10+ files, cross-cutting concerns, 500+ LOC affected

**Investigation Depth Assignment**:
- Low Complexity → Single-pass audit
- Medium Complexity → 2-3 targeted subagents
- High Complexity → 5+ parallel subagents
</task_assessment>

---

### PHASE 2: EXHAUSTIVE INVESTIGATION

<requirements_inventory>
#### Step 1: Comprehensive Requirements List

Document EVERYTHING required for implementation:
- Files that must exist or be modified
- Dependencies between components
- Data structures and schemas
- API contracts and endpoints
- UI elements and components
- State management requirements
- Configuration changes
- Environment variables
</requirements_inventory>

<parallel_investigation>
#### Step 2: Scaled Investigation Strategy

**For Low Complexity Tasks**:
1. Audit all affected files
2. Verify dependency chain
3. Document findings in single pass

**For Medium Complexity Tasks**:
1. Divide requirements into 2-3 logical investigation chunks
2. Launch targeted subagents for each chunk
3. Each subagent documents:
   - Components that exist and function correctly
   - Components that exist but are broken
   - Components that don't exist
   - Modifications required

**For High Complexity Tasks**:
1. Divide requirements into 5+ logical investigation chunks
2. Launch parallel subagents for deep-dive analysis
3. Each subagent provides detailed report:
   - Current state with exact file paths and line numbers
   - Broken/missing components with specific details
   - Required changes with concrete specifications
   - Dependencies on other investigation chunks
</parallel_investigation>

<iterative_refinement>
#### Step 3: Gap Analysis and Re-Investigation

If initial investigation reveals:
- Incomplete understanding of current state
- Assumptions required to proceed
- Unclear dependencies
- Ambiguous requirements

Then:
1. Identify specific knowledge gaps
2. Launch additional targeted subagents
3. Repeat investigation until zero-assumption clarity achieved
4. Document all findings in working .md files
</iterative_refinement>

---

### PHASE 3: DOCUMENTATION STRUCTURE

<file_organization>
**Base Path**: `/Scrapbook/[task_type]/[task_name]/`

**Required Files**:
1. `investigation_findings.md` - Complete audit results
2. `implementation_plan.md` - **PRIMARY DELIVERABLE** - Execution blueprint
3. `dependencies_map.md` - Component relationships and execution sequence
4. `testing_checklist.md` - Validation procedures for executor

**Formatting Standards**:
- Detailed without verbosity
- Concise and actionable
- Exact file paths (absolute paths preferred)
- Line numbers when modifying existing code
- Clear dependency markers
- Execution order without time estimates
- No assumptions or ambiguity
</file_organization>

---

### PHASE 4: IMPLEMENTATION PLAN CREATION

<deliverable_structure>
Create `/Scrapbook/[task_type]/[task_name]/implementation_plan.md` with following structure:

#### Section 1: Current State Summary
```
- Components that exist and function correctly
  - File: /exact/path/to/file.ts (lines X-Y)
  - Functionality: [description]

- Components that exist but are broken
  - File: /exact/path/to/file.ts (lines X-Y)
  - Issue: [specific problem]
  - Impact: [what this breaks]

- Components that don't exist
  - Required: [component name/description]
  - Purpose: [why it's needed]
  - Dependencies: [what depends on this]
```

#### Section 2: Required Changes
```
**Files to Create**:
- /path/to/new/file.ts - [purpose]

**Files to Modify**:
- /path/to/existing/file.ts - [specific changes needed]

**Files to Delete/Deprecate**:
- /path/to/old/file.ts - [reason for removal]

**Configuration Updates**:
- [config file]: [specific changes]
```

#### Section 3: Execution Sequence
```
Step 1: [Task Description]
- Action: [specific action required]
- Dependencies: [what must be complete first]
- Rationale: [why this order]

Step 2: [Task Description]
- Action: [specific action required]
- Dependencies: Step 1
- Rationale: [why this order]

[Continue for all steps...]
```

#### Section 4: File-by-File Specifications
```
**File**: /exact/path/to/file.ts

**Modification Type**: [Create New | Modify Existing | Delete]

**Current State** (if modifying):
Lines X-Y: [relevant existing code or description]

**Required Changes**:
[Exact code changes, pseudocode, or detailed specifications]

**Rationale**:
[Why this change is necessary]

**Dependencies**:
[What this change depends on or affects]
```

#### Section 5: Testing Checkpoints
```
**After Step X**:
- Test: [what to verify]
- Expected: [expected outcome]
- Validation method: [how to verify]

**After Step Y**:
- Test: [what to verify]
- Expected: [expected outcome]
- Validation method: [how to verify]
```

#### Section 6: Rollback Strategy
```
**Safe Stopping Points**:
- After Step X: [state at this point]
- After Step Y: [state at this point]

**Rollback Procedures**:
- From Step X: [how to undo]
- From Step Y: [how to undo]

**Data Preservation**:
- [what must be preserved during rollback]
```
</deliverable_structure>

---

## SUCCESS CRITERIA

<validation_checklist>
The implementation plan is complete when ALL criteria are met:

- [ ] Current state is documented with exact file paths and line numbers
- [ ] All broken/missing components are specifically identified
- [ ] All required changes are concretely specified
- [ ] Zero assumptions made - all ambiguities resolved
- [ ] Plan is actionable without additional research
- [ ] Executor can follow plan without clarification questions
- [ ] Context is preserved for future sessions
- [ ] Documentation enables clean hand-offs between sessions
</validation_checklist>

---

## STRATEGIC CONTEXT

<purpose_statement>
**Why .md Documentation Matters**:

These files are conversation save points and execution blueprints:
- Preserve complete investigation findings permanently
- Enable new Claude Code sessions to execute without re-research
- Provide maximum context in minimal tokens
- Create hand-off ready artifacts for any executor (human or AI)

**Token Economics**:
- Invest tokens NOW in thorough investigation
- Recover tokens LATER by reading plans instead of re-investigating
- Enable clean session transitions without context loss
</purpose_statement>

---

## OUTPUT GUARANTEE

<expected_deliverables>
Upon protocol completion, you will have:

1. **Complete Investigation**: All findings documented in `/Scrapbook/`
2. **Bulletproof Plan**: Execution-ready implementation blueprint
3. **Zero Ambiguity**: No questions needed to begin implementation
4. **Preserved Context**: Full state saved for future reference

**Critical Boundary**: This protocol STOPS after plan creation. Implementation is a separate execution phase.
</expected_deliverables>

---

## USAGE INSTRUCTIONS

To use this protocol:

1. Provide task description to Claude Code
2. Reference this prompt
3. Wait for complete investigation and planning phase
4. Review generated plan in `/Scrapbook/[task_type]/[task_name]/`
5. Execute plan in separate session or hand off to executor

**Note**: Do not request implementation during planning phase. Separation of concerns ensures plan quality.

---

## LIMITATIONS OF v1.0.0

This version was limited to **code implementation tasks only**. It could not handle:
- Workflow design or process improvement
- General project planning
- Research and analysis tasks
- Content creation planning
- Non-code resource acquisition
- Learning and skill development planning

**See v2.0.0 for dual-mode operation** supporting both code and general task planning.
